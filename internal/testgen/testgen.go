package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strings"
)

func main() {
	err := generateReaderCheckers()
	if err != nil {
		log.Fatal(err)
	}
}

func generateReaderCheckers() error {
	rdrs, err := readerFuncs()
	if err != nil {
		return err
	}

	out, err := os.Create("readers_gen_test.go")
	if err != nil {
		return err
	}
	_, err = fmt.Fprintln(out, `// Code generated by gen/testgen. DO NOT EDIT.

package rjson

import "testing"`)

	if err != nil {
		return err
	}

	for _, fn := range rdrs {
		_, err = fmt.Fprint(out, generateReaderChecker(fn))
		if err != nil {
			return err
		}
	}
	return nil
}

func generateReaderChecker(readerName string) string {
	checkVal := `got`
	params := `data`
	recurse := true
	if readerName == "ReadArray" || readerName == "ReadObject" {
		recurse = false
	}
	if strings.HasPrefix(readerName, "ReadString") {
		checkVal = `string(got)`
		params = `data, nil`
	}
	checkerName := "gen" + readerName + "Checker"

	return fmt.Sprintf(`
func Test%s_gen(t *testing.T) {
	t.Parallel()
	testReadChecker(t, %s, %v)
}

func %s(t *testing.T, data []byte) int {
	t.Helper()
	got, p, err := %s(%s)
	return assertMatchesUnmarshal(t, data, %s, p, err)
}
`, readerName, checkerName, recurse, checkerName, readerName, params, checkVal)
}

func readerFuncs() ([]string, error) {
	var result []string
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, "readers.go", nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}
	for _, f := range node.Decls {
		fn, ok := f.(*ast.FuncDecl)
		if !ok ||
			!strings.HasPrefix(fn.Name.Name, "Read") ||
			fn.Recv != nil {
			continue
		}
		name := fn.Name.Name
		if len(fn.Type.Results.List) != 3 && name != "ReadInt" {
			continue
		}
		result = append(result, name)
	}
	return result, nil
}
